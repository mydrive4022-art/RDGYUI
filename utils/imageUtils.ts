
export const fileToBase64 = (file: File): Promise<string> => {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = () => {
      const result = reader.result as string;
      const base64 = result.split(',')[1];
      resolve(base64);
    };
    reader.onerror = (error) => reject(error);
  });
};

/**
 * Removes a specific Chroma Key color (Neon Green #00FF00) generated by the AI.
 * This is the most robust way to handle "holes" in text/leaves while preserving eyes.
 */
export const makeTransparent = async (
  base64Image: string, 
  threshold: number = 50 // Tolerance for the green chroma key
): Promise<string> => {
  return new Promise((resolve) => {
    const img = new Image();
    img.crossOrigin = "anonymous";
    img.src = `data:image/png;base64,${base64Image}`;
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      if (!ctx) return resolve(`data:image/png;base64,${base64Image}`);

      ctx.drawImage(img, 0, 0);
      const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
      const data = imageData.data;

      // Target Color: Neon Green (0, 255, 0)
      for (let i = 0; i < data.length; i += 4) {
        const r = data[i];
        const g = data[i + 1];
        const b = data[i + 2];
        
        // Chroma key logic: Is it "Green enough" and not much red/blue?
        // We look for pixels where green is dominant and red/blue are low
        if (g > 150 && r < 120 && b < 120) {
           data[i + 3] = 0; // Transparent
        }
        
        // Also handle the edges - if it's mostly green, blend it
        const greenness = g - Math.max(r, b);
        if (greenness > 30) {
            // Simple alpha matting based on how "green" it is
            const alpha = Math.max(0, 255 - (greenness * 2));
            if (alpha < data[i + 3]) {
                data[i + 3] = alpha;
            }
        }
      }

      ctx.putImageData(imageData, 0, 0);
      resolve(canvas.toDataURL('image/png'));
    };
    img.onerror = () => resolve(`data:image/png;base64,${base64Image}`);
  });
};

export const applyBackgroundColor = async (
  transparentDataUrl: string,
  color: string
): Promise<string> => {
  if (color === 'transparent' || !color) return transparentDataUrl;
  
  return new Promise((resolve) => {
    const img = new Image();
    img.src = transparentDataUrl;
    img.onload = () => {
      const canvas = document.createElement('canvas');
      canvas.width = img.width;
      canvas.height = img.height;
      const ctx = canvas.getContext('2d');
      if (!ctx) return resolve(transparentDataUrl);

      ctx.fillStyle = color;
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(img, 0, 0);
      
      resolve(canvas.toDataURL('image/png'));
    };
    img.onerror = () => resolve(transparentDataUrl);
  });
};
